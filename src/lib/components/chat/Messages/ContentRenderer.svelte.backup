<script>
import { onDestroy, onMount, tick, getContext } from 'svelte';
const i18n = getContext('i18n');

import Markdown from './Markdown.svelte';
import {
artifactCode,
chatId,
mobile,
settings,
showArtifacts,
showControls,
showOverview
} from '$lib/stores';
import FloatingButtons from '../ContentRenderer/FloatingButtons.svelte';
import { createMessagesList } from '$lib/utils';
import { parseArtifactsFromContent, hasArtifactTags } from '$lib/utils/artifacts/xml-artifact-parser';
import ArtifactRenderer from '$lib/components/artifacts/ArtifactRenderer.svelte';

export let id;
export let content;

export let history;
export let messageId;

export let selectedModels = [];

export let done = true;
export let model = null;
export let sources = null;

export let save = false;
export let preview = false;
export let floatingButtons = true;

export let editCodeBlock = true;
export let topPadding = false;

export let onSave = (e) => {};
export let onSourceClick = (e) => {};
export let onTaskClick = (e) => {};
export let onAddMessages = (e) => {};

let contentContainerElement;
let floatingButtonsElement;

// Streaming artifact state
let streamingArtifact = null;
let lastProcessedContent = '';
let contentWithoutArtifacts = '';
let parsedArtifacts = [];
let artifactViewerActive = false;
let isStreaming = false;

const updateButtonPosition = (event) => {
const buttonsContainerElement = document.getElementById(`floating-buttons-${id}`);
if (
!contentContainerElement?.contains(event.target) &&
!buttonsContainerElement?.contains(event.target)
) {
closeFloatingButtons();
return;
}

setTimeout(async () => {
await tick();

if (!contentContainerElement?.contains(event.target)) return;

let selection = window.getSelection();

if (selection.toString().trim().length > 0) {
const range = selection.getRangeAt(0);
const rect = range.getBoundingClientRect();

const parentRect = contentContainerElement.getBoundingClientRect();

// Adjust based on parent rect
const top = rect.bottom - parentRect.top;
const left = rect.left - parentRect.left;

if (buttonsContainerElement) {
buttonsContainerElement.style.display = 'block';

// Calculate space available on the right
const spaceOnRight = parentRect.width - left;
let halfScreenWidth = $mobile ? window.innerWidth / 2 : window.innerWidth / 3;

if (spaceOnRight < halfScreenWidth) {
const right = parentRect.right - rect.right;
buttonsContainerElement.style.right = `${right}px`;
buttonsContainerElement.style.left = 'auto'; // Reset left
} else {
// Enough space, position using 'left'
buttonsContainerElement.style.left = `${left}px`;
buttonsContainerElement.style.right = 'auto'; // Reset right
}
buttonsContainerElement.style.top = `${top + 5}px`; // +5 to add some spacing
}
} else {
closeFloatingButtons();
}
}, 0);
};

const closeFloatingButtons = () => {
const buttonsContainerElement = document.getElementById(`floating-buttons-${id}`);
if (buttonsContainerElement) {
buttonsContainerElement.style.display = 'none';
}

if (floatingButtonsElement) {
// check if closeHandler is defined

if (typeof floatingButtonsElement?.closeHandler === 'function') {
// call the closeHandler function
floatingButtonsElement?.closeHandler();
}
}
};

const keydownHandler = (e) => {
if (e.key === 'Escape') {
closeFloatingButtons();
}
};

// Function to detect streaming artifacts
const detectStreamingArtifact = (currentContent) => {
// Check if we have a new artifact starting
const artifactStart = currentContent.indexOf('<artifact');
if (artifactStart !== -1 && !streamingArtifact) {
console.log('ðŸŽ¯ [Streaming] Detected artifact start at position:', artifactStart);

// Extract what we have so far of the artifact
const artifactPortion = currentContent.substring(artifactStart);

// Check if we have a complete opening tag
const openingTagEnd = artifactPortion.indexOf('>');
if (openingTagEnd !== -1) {
console.log('ðŸŽ¯ [Streaming] Found complete opening tag');

// Start the artifact viewer immediately
showArtifacts.set(true);
showControls.set(true);

// Track streaming state
streamingArtifact = {
startPosition: artifactStart,
hasContent: false
};
}
return true;
}

// Check if we have a closing tag (artifact complete)
if (streamingArtifact && currentContent.includes('</artifact>')) {
console.log('ðŸŽ¯ [Streaming] Detected artifact completion');

// Process the complete artifact
processCompletedArtifact(currentContent);
streamingArtifact = null;
return true;
}

return false;
};

// Function to process completed streaming artifact
const processCompletedArtifact = async (fullContent) => {
try {
console.log('ðŸŽ¯ [Streaming] Processing completed artifact');
const { artifactUtils } = await import('$lib/utils/artifacts/integration');
const artifacts = artifactUtils.postprocessResponse(fullContent, messageId);

if (artifacts.length > 0) {
console.log('ðŸŽ¯ [Streaming] Found', artifacts.length, 'artifacts');
const { artifactStore, uiState } = await import('$lib/stores/artifacts/artifact-store');
artifacts.forEach(artifact => {
artifactStore.addArtifact(artifact);
});
uiState.setVisible(true);
showArtifacts.set(true);
showControls.set(true);
}
} catch (error) {
console.error('ðŸŽ¯ [Streaming] Error processing completed artifact:', error);
}
};

onMount(() => {
if (floatingButtons) {
contentContainerElement?.addEventListener('mouseup', updateButtonPosition);
document.addEventListener('mouseup', updateButtonPosition);
document.addEventListener('keydown', keydownHandler);
}
});

onDestroy(() => {
if (floatingButtons) {
contentContainerElement?.removeEventListener('mouseup', updateButtonPosition);
document.removeEventListener('mouseup', updateButtonPosition);
document.removeEventListener('keydown', keydownHandler);
}
});

// Watch content changes for streaming detection
$: if (content !== lastProcessedContent) {
console.log('ðŸŽ¯ [Streaming] Content changed, checking for artifacts');
detectStreamingArtifact(content);
lastProcessedContent = content;
}
</script>

<div bind:this={contentContainerElement}>
<Markdown
{id}
{content}
{model}
{save}
{preview}
{done}
{editCodeBlock}
{topPadding}
sourceIds={(sources ?? []).reduce((acc, source) => {
let ids = [];
source.document.forEach((document, index) => {
if (model?.info?.meta?.capabilities?.citations == false) {
ids.push('N/A');
return ids;
}

const metadata = source.metadata?.[index];
const id = metadata?.source ?? 'N/A';

if (metadata?.name) {
ids.push(metadata.name);
return ids;
}

if (id.startsWith('http://') || id.startsWith('https://')) {
ids.push(id);
} else {
ids.push(source?.source?.name ?? id);
}

return ids;
});

acc = [...acc, ...ids];

// remove duplicates
return acc.filter((item, index) => acc.indexOf(item) === index);
}, [])}
{onSourceClick}
{onTaskClick}
{onSave}
onUpdate={(token) => {
const { lang, text: code } = token;

// Import artifact integration utilities
const processArtifactsFromResponse = async () => {
try {
const { artifactUtils } = await import('$lib/utils/artifacts/integration');
const artifacts = artifactUtils.postprocessResponse(content, messageId);
if (artifacts.length > 0) {
const { artifactStore, uiState } = await import('$lib/stores/artifacts/artifact-store');
artifacts.forEach(artifact => {
artifactStore.addArtifact(artifact);
});
uiState.setVisible(true);
showArtifacts.set(true);
showControls.set(true);
return true;
}
} catch (error) {
console.error('Error processing PAS 3.0 artifacts:', error);
}
return false;
};

// Try PAS 3.0 artifact detection first (for completed artifacts)
if (done) {
processArtifactsFromResponse().then(hasArtifacts => {
if (hasArtifacts) {
return; // PAS 3.0 artifacts found, skip legacy detection
}

// Fallback to legacy artifact detection
if (
($settings?.detectArtifacts ?? true) &&
((['html', 'svg', 'tsx', 'jsx', 'svelte'].includes(lang)) || (lang === 'xml' && code.includes('svg'))) &&
!$mobile &&
$chatId
) {
showArtifacts.set(true);
showControls.set(true);
}
});
}
}}
onPreview={async (value) => {
console.log('Preview', value);
await artifactCode.set(value);
await showControls.set(true);
await showArtifacts.set(true);
await showOverview.set(false);
}}
/>
</div>

{#if floatingButtons && model}
<FloatingButtons
bind:this={floatingButtonsElement}
{id}
{messageId}
actions={$settings?.floatingActionButtons ?? []}
model={(selectedModels ?? []).includes(model?.id)
? model?.id
: (selectedModels ?? []).length > 0
? selectedModels.at(0)
: model?.id}
messages={createMessagesList(history, id)}
onAdd={({ modelId, parentId, messages }) => {
console.log(modelId, parentId, messages);
onAddMessages({ modelId, parentId, messages });
closeFloatingButtons();
}}
/>
{/if}
